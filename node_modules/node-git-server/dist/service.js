"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Service = void 0;
const zlib_1 = __importDefault(require("zlib"));
const through_1 = __importDefault(require("through"));
const util_1 = __importDefault(require("util"));
const os_1 = __importDefault(require("os"));
const child_process_1 = require("child_process");
const http_duplex_1 = require("./http-duplex");
const util_2 = require("./util");
const headerRegex = {
    'receive-pack': '([0-9a-fA-F]+) ([0-9a-fA-F]+) refs\/(heads|tags)\/(.*?)( |00|\u0000)|^(0000)$',
    'upload-pack': '^\\S+ ([0-9a-fA-F]+)',
};
const decoder = {
    gzip: () => zlib_1.default.createGunzip(),
    deflate: () => zlib_1.default.createDeflate(),
};
class Service extends http_duplex_1.HttpDuplex {
    /**
     * Handles invoking the git-*-pack binaries
     * @param  opts - options to bootstrap the service object
     * @param  req  - http request object
     * @param  res  - http response
     */
    constructor(opts, req, res) {
        super(req, res);
        let data = '';
        this.status = 'pending';
        this.repo = opts.repo;
        this.service = opts.service;
        this.cwd = opts.cwd;
        this.logs = [];
        const buffered = (0, through_1.default)().pause();
        // stream needed to receive data after decoding, but before accepting
        const ts = (0, through_1.default)();
        const encoding = req.headers['content-encoding'];
        if (encoding && decoder[encoding]) {
            // data is compressed with gzip or deflate
            req.pipe(decoder[encoding]()).pipe(ts).pipe(buffered);
        }
        else {
            // data is not compressed
            req.pipe(ts).pipe(buffered);
        }
        if (req.headers['authorization']) {
            const tokens = req.headers['authorization'].split(' ');
            if (tokens[0] === 'Basic') {
                const splitHash = Buffer.from(tokens[1], 'base64')
                    .toString('utf8')
                    .split(':');
                this.username = splitHash.shift();
            }
        }
        ts.once('data', (chunk) => {
            data += chunk;
            const ops = data.match(new RegExp(headerRegex[this.service], 'gi'));
            if (!ops)
                return;
            data = '';
            ops.forEach((op) => {
                let type;
                const m = op.match(new RegExp(headerRegex[this.service]));
                if (!m)
                    return;
                if (this.service === 'receive-pack') {
                    this.last = m[1];
                    this.commit = m[2];
                    if (m[3] == 'heads') {
                        type = 'branch';
                        this.evName = 'push';
                    }
                    else {
                        type = 'version';
                        this.evName = 'tag';
                    }
                    const headers = {
                        last: this.last,
                        commit: this.commit,
                    };
                    headers[type] = this[type] = m[4];
                    this.emit('header', headers);
                }
                else if (this.service === 'upload-pack') {
                    this.commit = m[1];
                    this.evName = 'fetch';
                    this.emit('header', {
                        commit: this.commit,
                    });
                }
            });
        });
        this.once('accept', () => {
            process.nextTick(() => {
                const cmd = os_1.default.platform() == 'win32'
                    ? ['git', opts.service, '--stateless-rpc', opts.cwd]
                    : ['git-' + opts.service, '--stateless-rpc', opts.cwd];
                const ps = (0, child_process_1.spawn)(cmd[0], cmd.slice(1));
                ps.on('error', (error) => {
                    this.emit('error', new Error(`${error.message} running command ${cmd.join(' ')}`));
                });
                this.emit('service', ps);
                const respStream = (0, through_1.default)(
                // write
                (c) => {
                    if (this.listeners('response').length === 0) {
                        if (this.logs.length > 0) {
                            while (this.logs.length > 0) {
                                respStream.queue(this.logs.pop());
                            }
                        }
                        return respStream.queue(c);
                    }
                    // prevent git from sending the close signal
                    if (c.length === 4 && c.toString() === '0000')
                        return;
                    respStream.queue(c);
                }, 
                // read
                () => {
                    if (this.listeners('response').length > 0)
                        return;
                    respStream.queue(null);
                });
                respStream.log = this.log.bind(this);
                this.emit('response', respStream, function endResponse() {
                    res.queue(Buffer.from('0000'));
                    res.queue(null);
                });
                ps.stdout.pipe(respStream).pipe(res);
                buffered.pipe(ps.stdin);
                buffered.resume();
                ps.on('exit', () => {
                    if (this.logs.length > 0) {
                        while (this.logs.length > 0) {
                            respStream.queue(this.logs.pop());
                        }
                        respStream.queue(Buffer.from('0000'));
                        respStream.queue(null);
                    }
                    this.emit('exit');
                });
            });
        });
        this.once('reject', function onReject(code, msg) {
            res.statusCode = code;
            res.end(msg);
        });
    }
    log() {
        // eslint-disable-next-line prefer-rest-params
        const _log = util_1.default.format(...arguments);
        const SIDEBAND = String.fromCharCode(2); // PROGRESS
        const message = `${SIDEBAND}${_log}\n`;
        const formattedMessage = Buffer.from((0, util_2.packSideband)(message));
        this.logs.unshift(formattedMessage.toString());
    }
    /**
     * reject request in flight
     * @param  code - http response code
     * @param  msg  - message that should be displayed on the client
     */
    reject(code, msg) {
        if (this.status !== 'pending')
            return;
        if (msg === undefined && typeof code === 'string') {
            msg = code;
            code = 500;
        }
        this.status = 'rejected';
        this.emit('reject', code || 500, msg);
    }
    /**
     * accepts request to access resource
     */
    accept() {
        if (this.status !== 'pending')
            return;
        this.status = 'accepted';
        this.emit('accept');
    }
}
exports.Service = Service;
