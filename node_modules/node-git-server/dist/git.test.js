"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const child_process_1 = require("child_process");
const http_1 = __importDefault(require("http"));
const git_1 = require("./git");
const wrapCallback = (func) => {
    return new Promise((resolve) => {
        func(resolve);
    });
};
describe('git', () => {
    test('create, push to, and clone a repo', async () => {
        expect.assertions(11);
        let lastCommit;
        const repoDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const srcDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const dstDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        fs_1.default.mkdirSync(repoDir, '0700');
        fs_1.default.mkdirSync(srcDir, '0700');
        fs_1.default.mkdirSync(dstDir, '0700');
        const repos = new git_1.Git(repoDir, {
            autoCreate: true,
        });
        const port = Math.floor(Math.random() * ((1 << 16) - 1e4)) + 1e4;
        const server = http_1.default
            .createServer((req, res) => {
            repos.handle(req, res);
        })
            .listen(port);
        repos.on('push', (push) => {
            expect(push.repo).toBe('xyz/doom');
            expect(push.commit).toBe(lastCommit);
            expect(push.branch).toBe('master');
            expect(push.headers.host).toBe('localhost:' + port);
            expect(push.method).toBe('POST');
            expect(push.url).toBe('/xyz/doom/git-receive-pack');
            push.accept();
        });
        await wrapCallback((callback) => {
            repos.mkdir('xyz');
            callback();
        });
        await wrapCallback((callback) => {
            repos.create('xyz/doom', () => {
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['init'], { cwd: srcDir }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            fs_1.default.writeFile(srcDir + '/a.txt', 'abcd', () => {
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['add', 'a.txt'], { cwd: srcDir }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['commit', '-am', 'a!!'], { cwd: srcDir }).on('exit', () => {
                (0, child_process_1.exec)('git log | head -n1', { cwd: srcDir }, (err, stdout) => {
                    lastCommit = stdout.split(/\s+/)[1];
                    callback();
                });
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['push', 'http://localhost:' + port + '/xyz/doom', 'master'], { cwd: srcDir }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['clone', 'http://localhost:' + port + '/xyz/doom'], {
                cwd: dstDir,
            }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        const ex = fs_1.default.existsSync(dstDir + '/doom/a.txt');
        expect(ex).toBeTruthy();
        server.close();
    });
    test('create, push to, and clone a repo successful', async () => {
        expect.assertions(8);
        const repoDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const srcDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const dstDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        fs_1.default.mkdirSync(repoDir, '0700');
        fs_1.default.mkdirSync(srcDir, '0700');
        fs_1.default.mkdirSync(dstDir, '0700');
        const repos = new git_1.Git(repoDir);
        const port = Math.floor(Math.random() * ((1 << 16) - 1e4)) + 1e4;
        const server = http_1.default.createServer((req, res) => {
            repos.handle(req, res);
        });
        server.listen(port);
        repos.on('push', (push) => {
            expect(push.repo).toBe('doom');
            push.accept();
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['init'], { cwd: srcDir }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            fs_1.default.writeFile(srcDir + '/a.txt', 'abcd', (err) => {
                expect(!err).toBeTruthy();
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['add', 'a.txt'], { cwd: srcDir }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['commit', '-am', 'a!!'], { cwd: srcDir }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['push', 'http://localhost:' + port + '/doom', 'master'], {
                cwd: srcDir,
            }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['clone', 'http://localhost:' + port + '/doom'], {
                cwd: dstDir,
            }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            fs_1.default.stat(dstDir + '/doom/a.txt', (ex) => {
                expect(!ex).toBeTruthy();
                callback();
            });
        });
        server.close();
    });
    test('clone into programatic directories', async () => {
        expect.assertions(19);
        const port = Math.floor(Math.random() * ((1 << 16) - 1e4)) + 1e4;
        const repoDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const srcDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const dstDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const targetDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        fs_1.default.mkdirSync(repoDir, '0700');
        fs_1.default.mkdirSync(srcDir, '0700');
        fs_1.default.mkdirSync(dstDir, '0700');
        fs_1.default.mkdirSync(targetDir, '0700');
        const server = new git_1.Git((dir) => {
            expect(dir).toBe('doom.git');
            return path_1.default.join(targetDir, dir || '');
        });
        server.listen(port);
        server.on('push', (push) => {
            expect(push.repo).toBe('doom.git');
            push.accept();
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['init'], { cwd: srcDir }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            fs_1.default.writeFile(srcDir + '/a.txt', 'abcd', (err) => {
                expect(!err).toBeTruthy();
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['add', 'a.txt'], {
                cwd: srcDir,
            }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['commit', '-am', 'a!!'], {
                cwd: srcDir,
            }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['push', 'http://localhost:' + port + '/doom.git', 'master'], {
                cwd: srcDir,
            }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['clone', 'http://localhost:' + port + '/doom.git'], {
                cwd: dstDir,
            }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            fs_1.default.stat(dstDir + '/doom/a.txt', (ex) => {
                expect(!ex).toBeTruthy();
                callback();
            });
        });
        await wrapCallback((callback) => {
            fs_1.default.stat(targetDir + '/doom.git/HEAD', (ex) => {
                expect(!ex).toBeTruthy();
                callback();
            });
        });
        server.close();
    });
    test('test tagging', async () => {
        expect.assertions(27);
        const repoDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const srcDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const dstDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        let lastCommit;
        fs_1.default.mkdirSync(repoDir, '0700');
        fs_1.default.mkdirSync(srcDir, '0700');
        fs_1.default.mkdirSync(dstDir, '0700');
        const repos = new git_1.Git(repoDir, {
            autoCreate: true,
        });
        const port = Math.floor(Math.random() * ((1 << 16) - 1e4)) + 1e4;
        const server = http_1.default.createServer((req, res) => {
            repos.handle(req, res);
        });
        server.listen(port);
        repos.on('push', (push) => {
            expect(push.repo).toBe('doom');
            expect(push.commit).toBe(lastCommit);
            expect(push.branch).toBe('master');
            expect(push.headers.host).toBe('localhost:' + port);
            expect(push.method).toBe('POST');
            expect(push.url).toBe('/doom/git-receive-pack');
            push.accept();
        });
        let firstTag = true;
        repos.on('tag', (tag) => {
            expect(tag.repo).toBe('doom');
            expect(tag.version).toBe('0.0.' + (firstTag ? 1 : 2));
            expect(tag.headers.host).toBe('localhost:' + port);
            expect(tag.method).toBe('POST');
            expect(tag.url).toBe('/doom/git-receive-pack');
            tag.accept();
            firstTag = false;
        });
        await wrapCallback((callback) => {
            repos.create('doom', () => {
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['init'], { cwd: srcDir }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            fs_1.default.writeFile(srcDir + '/a.txt', 'abcd', (err) => {
                expect(!err).toBeTruthy();
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['add', 'a.txt'], { cwd: srcDir }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['commit', '-am', 'a!!'], { cwd: srcDir }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['tag', '0.0.1'], { cwd: srcDir }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            fs_1.default.writeFile(srcDir + '/a.txt', 'efgh', (err) => {
                expect(!err).toBeTruthy();
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['add', 'a.txt'], { cwd: srcDir }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['commit', '-am', 'a!!'], { cwd: srcDir }).on('exit', () => {
                (0, child_process_1.exec)('git log | head -n1', { cwd: srcDir }, (err, stdout) => {
                    lastCommit = stdout.split(/\s+/)[1];
                    callback();
                });
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['tag', '0.0.2'], { cwd: srcDir }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['push', '--tags', 'http://localhost:' + port + '/doom', 'master'], { cwd: srcDir }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['clone', 'http://localhost:' + port + '/doom'], {
                cwd: dstDir,
            }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            fs_1.default.exists(dstDir + '/doom/a.txt', (ex) => {
                expect(ex).toBeTruthy();
                callback();
            });
        });
        server.close();
    });
    describe('repos list', () => {
        const workingRepoDir = path_1.default.resolve(__dirname, '..', 'fixtures', 'server', 'tmp');
        const notWorkingRepoDir = path_1.default.resolve(__dirname, '..', 'fixtures', 'server', 'temp');
        test('should return back with one directory in server', async () => {
            expect.assertions(2);
            await new Promise((resolve) => {
                const repos = new git_1.Git(workingRepoDir, {
                    autoCreate: true,
                });
                repos.list((err, results) => {
                    expect(err).toBeFalsy();
                    expect(['test.git']).toEqual(results);
                    resolve('passed');
                });
            });
        }, 15000);
        test('should return back error directory does not exist', async () => {
            expect.assertions(2);
            await new Promise((resolve) => {
                const repos = new git_1.Git(notWorkingRepoDir, {
                    autoCreate: true,
                });
                repos.list((err, results) => {
                    expect(err !== null).toBeTruthy();
                    expect(results === undefined).toBeTruthy();
                    resolve('passed');
                });
            });
        });
    });
    test('create, push to, and clone a repo reject', async () => {
        expect.assertions(12);
        function _spawn(cmd, args, opts) {
            const ps = (0, child_process_1.spawn)(cmd, args, opts);
            ps.on('error', (err) => {
                console.error(
                // eslint-disable-line
                err.message + ' while executing: ' + cmd + ' ' + args?.join(' '));
            });
            return ps;
        }
        let lastCommit;
        const repoDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const srcDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const dstDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        fs_1.default.mkdirSync(repoDir, '0700');
        fs_1.default.mkdirSync(srcDir, '0700');
        fs_1.default.mkdirSync(dstDir, '0700');
        const repos = new git_1.Git(repoDir, {
            autoCreate: true,
        });
        const port = Math.floor(Math.random() * ((1 << 16) - 1e4)) + 1e4;
        const server = http_1.default.createServer((req, res) => {
            repos.handle(req, res);
        });
        server.listen(port);
        repos.on('push', (push) => {
            expect(push.repo).toBe('doom');
            expect(push.commit).toBe(lastCommit);
            expect(push.branch).toBe('master');
            expect(push.headers.host).toBe('localhost:' + port);
            expect(push.method).toBe('POST');
            expect(push.url).toBe('/doom/git-receive-pack');
            push.reject(500, 'ACCESS DENIED');
        });
        await wrapCallback((callback) => {
            repos.create('doom', () => {
                callback();
            });
        });
        await wrapCallback((callback) => {
            _spawn('git', ['init'], { cwd: srcDir }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            fs_1.default.writeFile(srcDir + '/a.txt', 'abcd', (err) => {
                expect(!err).toBeTruthy();
                callback();
            });
        });
        await wrapCallback((callback) => {
            _spawn('git', ['add', 'a.txt'], { cwd: srcDir }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            _spawn('git', ['commit', '-am', 'a!!'], { cwd: srcDir }).on('exit', () => {
                (0, child_process_1.exec)('git log | head -n1', { cwd: srcDir }, (err, stdout) => {
                    lastCommit = stdout.split(/\s+/)[1];
                    callback();
                });
            });
        });
        await wrapCallback((callback) => {
            _spawn('git', ['push', 'http://localhost:' + port + '/doom', 'master'], {
                cwd: srcDir,
            }).on('exit', (code) => {
                expect(code).not.toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            const glog = _spawn('git', ['log'], {
                cwd: repoDir + '/doom.git',
            });
            glog.on('exit', (code) => {
                expect(code).toBe(128);
                callback();
            });
            let data = '';
            glog.stderr.on('data', (buf) => (data += buf));
            glog.stderr.on('end', () => {
                const res = /fatal: bad default revision 'HEAD'/.test(data) ||
                    /fatal: your current branch 'master' does not have any commits yet/.test(data);
                expect(res).toBeTruthy();
            });
        });
        server.close();
    });
    test('create git server via listen() command', async () => {
        const repoDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const srcDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const dstDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        fs_1.default.mkdirSync(repoDir, '0700');
        fs_1.default.mkdirSync(srcDir, '0700');
        fs_1.default.mkdirSync(dstDir, '0700');
        const repos = new git_1.Git(repoDir);
        const port = Math.floor(Math.random() * ((1 << 16) - 1e4)) + 1e4;
        expect(repos.listen(port)).toBe(repos);
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['clone', 'http://localhost:' + port + '/doom'], {
                cwd: dstDir,
            }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        repos.close();
    });
    test('should return promise that resolves when server is closed if no callback specified', async () => {
        await new Promise((resolve) => {
            const repoDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
            fs_1.default.mkdirSync(repoDir, '0700');
            const repos = new git_1.Git(repoDir);
            const port = Math.floor(Math.random() * ((1 << 16) - 1e4)) + 1e4;
            repos.listen(port, undefined, () => {
                repos.close().then(() => {
                    resolve('passed');
                });
            });
        });
    });
    test('should be able to protect certain routes', async () => {
        const repoDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const srcDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const dstDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        fs_1.default.mkdirSync(repoDir, '0700');
        fs_1.default.mkdirSync(srcDir, '0700');
        fs_1.default.mkdirSync(dstDir, '0700');
        const repos = new git_1.Git(repoDir, {
            autoCreate: true,
            authenticate: ({ type, repo, user }, next) => {
                if (type === 'fetch' && repo === 'doom') {
                    user((username, password) => {
                        if (username == 'root' && password == 'root') {
                            next();
                        }
                        else {
                            next(new Error('that is not the correct password'));
                        }
                    });
                }
                else {
                    next(new Error('that is not the correct password'));
                }
            },
        });
        const port = Math.floor(Math.random() * ((1 << 16) - 1e4)) + 1e4;
        repos.listen(port);
        await wrapCallback((callback) => {
            const clone = (0, child_process_1.spawn)('git', ['clone', `http://root:root@localhost:${port}/doom.git`], { cwd: dstDir });
            clone.on('close', function (code) {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            const clone = (0, child_process_1.spawn)('git', ['clone', `http://root:world@localhost:${port}/doom.git doom1`], { cwd: dstDir });
            let error = '';
            clone.stderr.on('data', (d) => {
                error += d.toString('utf8');
            });
            clone.on('close', function (code) {
                expect(error).toBe(`Cloning into 'doom.git doom1'...\nfatal: unable to access 'http://localhost:${port}/doom.git doom1/': URL using bad/illegal format or missing URL\n`);
                expect(code).toBe(128);
                callback();
            });
        });
        repos.close();
    });
    test('should be able to access headers in authenticate', async () => {
        expect.assertions(13);
        const repoDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const srcDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const dstDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        fs_1.default.mkdirSync(repoDir, '0700');
        fs_1.default.mkdirSync(srcDir, '0700');
        fs_1.default.mkdirSync(dstDir, '0700');
        const repos = new git_1.Git(repoDir, {
            autoCreate: true,
            authenticate: ({ type, repo, user, headers }, next) => {
                if (type === 'fetch' && repo === 'doom') {
                    expect(headers['host']).toBeTruthy();
                    expect(headers['user-agent']).toBeTruthy();
                    expect(headers['accept']).toBeTruthy();
                    expect(headers['pragma']).toBeTruthy();
                    expect(headers['accept-encoding']).toBeTruthy();
                    user((username, password) => {
                        if (username == 'root' && password == 'root') {
                            next();
                        }
                        else {
                            next(new Error('that is not the correct password'));
                        }
                    });
                }
                else {
                    next(new Error('that is not the correct password'));
                }
            },
        });
        const port = Math.floor(Math.random() * ((1 << 16) - 1e4)) + 1e4;
        repos.listen(port);
        await wrapCallback((callback) => {
            const clone = (0, child_process_1.spawn)('git', ['clone', `http://root:root@localhost:${port}/doom.git`], { cwd: dstDir });
            clone.on('close', function (code) {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            const clone = (0, child_process_1.spawn)('git', ['clone', `http://root:world@localhost:${port}/doom.git doom1`], { cwd: dstDir });
            let error = '';
            clone.stderr.on('data', (d) => {
                error += d.toString('utf8');
            });
            clone.on('close', function (code) {
                expect(error).toBe(`Cloning into 'doom.git doom1'...\nfatal: unable to access 'http://localhost:${port}/doom.git doom1/': URL using bad/illegal format or missing URL\n`);
                expect(code).toBe(128);
                callback();
            });
        });
        repos.close();
    });
    test('should be able to protect certain routes with a promised authenticate', async () => {
        const repoDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const srcDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const dstDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        fs_1.default.mkdirSync(repoDir, '0700');
        fs_1.default.mkdirSync(srcDir, '0700');
        fs_1.default.mkdirSync(dstDir, '0700');
        const repos = new git_1.Git(repoDir, {
            autoCreate: true,
            authenticate: ({ type, repo, user }) => {
                return new Promise(function (resolve, reject) {
                    if (type === 'fetch' && repo === 'doom') {
                        user((username, password) => {
                            if (username == 'root' && password == 'root') {
                                return resolve(void 0);
                            }
                            else {
                                return reject('that is not the correct password');
                            }
                        });
                    }
                    else {
                        return reject('that is not the correct password');
                    }
                });
            },
        });
        const port = Math.floor(Math.random() * ((1 << 16) - 1e4)) + 1e4;
        repos.listen(port);
        await wrapCallback((callback) => {
            const clone = (0, child_process_1.spawn)('git', ['clone', `http://root:root@localhost:${port}/doom.git`], { cwd: dstDir });
            clone.on('close', function (code) {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            const clone = (0, child_process_1.spawn)('git', ['clone', `http://root:world@localhost:${port}/doom.git doom1`], { cwd: dstDir });
            let error = '';
            clone.stderr.on('data', (d) => {
                error += d.toString('utf8');
            });
            clone.on('close', function (code) {
                expect(error).toBe(`Cloning into 'doom.git doom1'...\nfatal: unable to access 'http://localhost:${port}/doom.git doom1/': URL using bad/illegal format or missing URL\n`);
                expect(code).toBe(128);
                callback();
            });
        });
        repos.close();
    });
    test('should be able to send custom messages to git client (main stream)', async () => {
        const repoDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const srcDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const dstDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        fs_1.default.mkdirSync(repoDir, '0700');
        fs_1.default.mkdirSync(srcDir, '0700');
        fs_1.default.mkdirSync(dstDir, '0700');
        const repos = new git_1.Git(repoDir, {
            autoCreate: true,
        });
        const port = Math.floor(Math.random() * ((1 << 16) - 1e4)) + 1e4;
        repos.on('push', (push) => {
            push.log(' ');
            push.log('Have a great day!');
            push.log(' ');
            push.accept();
        });
        repos.listen(port);
        await wrapCallback((callback) => {
            repos.create('doom', () => {
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['init'], { cwd: srcDir }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            fs_1.default.writeFile(srcDir + '/a.txt', 'abcd', () => {
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['add', 'a.txt'], { cwd: srcDir }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['commit', '-m', 'a!!'], { cwd: srcDir }).on('exit', () => {
                callback();
            });
        });
        await wrapCallback((callback) => {
            const logs = [];
            const push = (0, child_process_1.spawn)('git', ['push', 'http://localhost:' + port + '/doom.git', 'master'], { cwd: srcDir });
            push.stdout.on('data', (data) => {
                if (data.toString() !== '') {
                    logs.push(data.toString());
                }
            });
            push.stderr.on('data', (data) => {
                if (data.toString() !== '') {
                    logs.push(data.toString());
                }
            });
            push.on('exit', () => {
                expect(logs.join(' ').indexOf('remote: Have a great day!') > -1).toBeTruthy();
                callback();
            });
        });
        repos.close();
    });
    test('should be able to send custom messages to git client (response stream)', async () => {
        const repoDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const srcDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        const dstDir = `/tmp/${Math.floor(Math.random() * (1 << 30)).toString(16)}`;
        fs_1.default.mkdirSync(repoDir, '0700');
        fs_1.default.mkdirSync(srcDir, '0700');
        fs_1.default.mkdirSync(dstDir, '0700');
        const repos = new git_1.Git(repoDir, {
            autoCreate: true,
        });
        const port = Math.floor(Math.random() * ((1 << 16) - 1e4)) + 1e4;
        repos.on('push', (push) => {
            console.log(`push ${push.repo}/${push.commit}`); // eslint-disable-line
            push.on('response', (stream) => {
                stream.log(' ');
                stream.log('Have a great day!');
                stream.log(' ');
            });
            push.accept();
        });
        repos.listen(port);
        await wrapCallback((callback) => {
            repos.create('doom', () => {
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['init'], { cwd: srcDir }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            fs_1.default.writeFile(srcDir + '/a.txt', 'abcd', () => {
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['add', 'a.txt'], { cwd: srcDir }).on('exit', (code) => {
                expect(code).toBe(0);
                callback();
            });
        });
        await wrapCallback((callback) => {
            (0, child_process_1.spawn)('git', ['commit', '-m', 'a!!'], { cwd: srcDir }).on('exit', () => {
                callback();
            });
        });
        await wrapCallback((callback) => {
            const logs = [];
            const push = (0, child_process_1.spawn)('git', ['push', 'http://localhost:' + port + '/doom.git', 'master'], { cwd: srcDir });
            push.stdout.on('data', (data) => {
                if (data.toString() !== '') {
                    logs.push(data.toString());
                }
            });
            push.stderr.on('data', (data) => {
                if (data.toString() !== '') {
                    logs.push(data.toString());
                }
            });
            push.on('exit', () => {
                expect(logs.join(' ').indexOf('remote: Have a great day!') > -1).toBeTruthy();
                callback();
            });
        });
        repos.close();
    });
});
