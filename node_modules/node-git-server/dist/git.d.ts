/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import http, { ServerOptions } from 'http';
import https from 'https';
import { HttpDuplex } from './http-duplex';
import { EventEmitter } from 'events';
interface GitServerOptions extends ServerOptions {
    type: 'http' | 'https';
}
export interface GitOptions {
    autoCreate?: boolean;
    authenticate?: (options: GitAuthenticateOptions, callback: (error?: Error) => void | undefined) => void | Promise<Error | undefined | void> | undefined;
    checkout?: boolean;
}
export interface GitAuthenticateOptions {
    type: string;
    repo: string;
    user: (() => Promise<[string | undefined, string | undefined]>) & ((callback: (username?: string | undefined, password?: string | undefined) => void) => void);
    headers: http.IncomingHttpHeaders;
}
/**
 * An http duplex object (see below) with these extra properties:
 */
export interface TagData extends HttpDuplex {
    repo: string;
    commit: string;
    version: string;
}
/**
 * Is a http duplex object (see below) with these extra properties
 */
export interface PushData extends HttpDuplex {
    repo: string;
    commit: string;
    branch: string;
}
/**
 * an http duplex object (see below) with these extra properties
 */
export interface FetchData extends HttpDuplex {
    repo: string;
    commit: string;
}
/**
 * an http duplex object (see below) with these extra properties
 */
export interface InfoData extends HttpDuplex {
    repo: string;
}
/**
 * an http duplex object (see below) with these extra properties
 */
export interface HeadData extends HttpDuplex {
    repo: string;
}
export interface GitEvents {
    /**
     * @example
     * repos.on('push', function (push) { ... }
     *
     * Emitted when somebody does a `git push` to the repo.
     *
     * Exactly one listener must call `push.accept()` or `push.reject()`. If there are
     * no listeners, `push.accept()` is called automatically.
     **/
    on(event: 'push', listener: (push: PushData) => void): this;
    /**
     * @example
     * repos.on('tag', function (tag) { ... }
     *
     * Emitted when somebody does a `git push --tags` to the repo.
     * Exactly one listener must call `tag.accept()` or `tag.reject()`. If there are
     * No listeners, `tag.accept()` is called automatically.
     **/
    on(event: 'tag', listener: (tag: TagData) => void): this;
    /**
     * @example
     * repos.on('fetch', function (fetch) { ... }
     *
     * Emitted when somebody does a `git fetch` to the repo (which happens whenever you
     * do a `git pull` or a `git clone`).
     *
     * Exactly one listener must call `fetch.accept()` or `fetch.reject()`. If there are
     * no listeners, `fetch.accept()` is called automatically.
     **/
    on(event: 'fetch', listener: (fetch: FetchData) => void): this;
    /**
     * @example
     * repos.on('info', function (info) { ... }
     *
     * Emitted when the repo is queried for info before doing other commands.
     *
     * Exactly one listener must call `info.accept()` or `info.reject()`. If there are
     * no listeners, `info.accept()` is called automatically.
     **/
    on(event: 'info', listener: (info: InfoData) => void): this;
    /**
     * @example
     * repos.on('head', function (head) { ... }
     *
     * Emitted when the repo is queried for HEAD before doing other commands.
     *
     * Exactly one listener must call `head.accept()` or `head.reject()`. If there are
     * no listeners, `head.accept()` is called automatically.
     *
     **/
    on(event: 'head', listener: (head: HeadData) => void): this;
}
export declare class Git extends EventEmitter implements GitEvents {
    dirMap: (dir?: string) => string;
    authenticate: ((options: GitAuthenticateOptions, callback: (error?: Error) => void | undefined) => void | Promise<Error | undefined | void> | undefined) | undefined;
    autoCreate: boolean;
    checkout: boolean | undefined;
    server: https.Server | http.Server | undefined;
    /**
     *
     * Handles invoking the git-*-pack binaries
     * @param  repoDir   - Create a new repository collection from the directory `repoDir`. `repoDir` should be entirely empty except for git repo directories. If `repoDir` is a function, `repoDir(repo)` will be used to dynamically resolve project directories. The return value of `repoDir(repo)` should be a string path specifying where to put the string `repo`. Make sure to return the same value for `repo` every time since `repoDir(repo)` will be called multiple times.
     * @param  options - options that can be applied on the new instance being created
     * @param  options.autoCreate - By default, repository targets will be created if they don't exist. You can
     disable that behavior with `options.autoCreate = true`
     * @param  options.authenticate - a function that has the following arguments ({ type, repo, username, password, headers }, next) and will be called when a request comes through if set
     *
       authenticate: ({ type, repo, username, password, headers }, next) => {
         console.log(type, repo, username, password);
         next();
       }
       // alternatively you can also pass authenticate a promise
       authenticate: ({ type, repo, username, password, headers }, next) => {
         console.log(type, repo, username, password);
         return new Promise((resolve, reject) => {
          if(username === 'foo') {
            return resolve();
          }
          return reject("sorry you don't have access to this content");
         });
       }
     * @param  options.checkout - If `opts.checkout` is true, create and expected checked-out repos instead of bare repos
    */
    constructor(repoDir: string | ((dir?: string) => string), options?: GitOptions);
    /**
     * Get a list of all the repositories
     * @param  {Function} callback function to be called when repositories have been found `function(error, repos)`
     */
    list(callback: (error: Error | undefined, repos?: string[]) => void): void;
    list(): Promise<string[]>;
    /**
     * Find out whether `repoName` exists in the callback `cb(exists)`.
     * @param  repo - name of the repo
     * @param  callback - function to be called when finished
     */
    exists(repo: string): boolean;
    /**
     * Create a subdirectory `dir` in the repo dir with a callback.
     * @param  dir - directory name
     * @param  callback  - callback to be called when finished
     */
    mkdir(dir: string): void;
    /**
     * Create a new bare repository `repoName` in the instance repository directory.
     * @param  repo - the name of the repo
     * @param  callback - Optionally get a callback `cb(err)` to be notified when the repository was created.
     */
    create(repo: string, callback: (error?: Error) => void): void;
    /**
     * returns the typeof service being process. This will respond with either fetch or push.
     * @param  service - the service type
     */
    getType(service: string): string;
    /**
     * Handle incoming HTTP requests with a connect-style middleware
     * @param  http request object
     * @param  http response object
     */
    handle(req: http.IncomingMessage, res: http.ServerResponse): void;
    /**
     * starts a git server on the given port
     * @param  port  - the port to start the server on
     * @param  options  - the options to add extended functionality to the server
     * @param  options.type - this is either https or http (the default is http)
     * @param  options.key - the key file for the https server
     * @param  options.cert - the cert file for the https server
     * @param  callback - the function to call when server is started or error has occurred
     */
    listen(port: number, options?: GitServerOptions, callback?: () => void): Git;
    /**
     * closes the server instance
     * @param will resolve or reject when the server closes or fails to close.
     */
    close(): Promise<string>;
}
export {};
//# sourceMappingURL=git.d.ts.map