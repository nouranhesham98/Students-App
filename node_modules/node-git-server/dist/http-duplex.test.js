"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const http_duplex_1 = require("./http-duplex");
const http_1 = __importDefault(require("http"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const fs_1 = require("fs");
// eslint-disable-next-line no-undef
const selfSrc = (0, fs_1.readFileSync)(__filename);
Object.prototype.serialize = () => {
    return JSON.stringify(this, null, 4);
};
Object.prototype.filterKeys = function (key) {
    Object.keys(this).forEach((i) => {
        if (i == key)
            delete this[i];
    });
    return this;
};
String.prototype.format = function () {
    // eslint-disable-next-line prefer-rest-params
    const args = Array.from(arguments);
    return this.replace(/{(\d+)}/g, function (match, number) {
        return typeof args[number] != 'undefined' ? args[number] : match;
    });
};
String.prototype.streamlineLineEndings = function (ending = '\n') {
    return this.replace(/[\r\n,\r,\n]+/g, ending);
};
String.prototype.streamlineSpace = function () {
    return this.replace(/[\f\t\v ]{2,}/g, ' ');
};
String.prototype.streamline = function (ending = '\n') {
    return this.streamlineSpace().streamlineLineEndings(ending);
};
describe('http-duplex', () => {
    let server;
    beforeEach(() => {
        console.log('create server');
        server = http_1.default.createServer(function (req, res) {
            const dup = new http_duplex_1.HttpDuplex(req, res);
            console.log(dup.method + ' ' + dup.url); // eslint-disable-line
            switch (dup.url) {
                case '/':
                    dup.setHeader('content-type', 'text/plain');
                    if (dup.method === 'POST') {
                        dup.end(dup.headers['content-length']);
                    }
                    else {
                        dup.end((0, fs_1.readFileSync)(__filename));
                    }
                    break;
                case '/info':
                    if (dup.method == 'GET') {
                        dup.setHeader('content-type', 'text/plain');
                        const output = ('Method: {0}\n' +
                            'Path: {1}\n' +
                            'Status: {2}\n' +
                            'Http Version 1: {3}\n' +
                            'Http Version 2: {4}\n' +
                            'Headers: \n{5}\n' +
                            'Trailers: {6}\n' +
                            'Complete: {7}\n' +
                            'Readable: {8}\n' +
                            'Writeable: {9}\n' +
                            'Connection: {10}\n' +
                            'Socket: {11}\n').format(dup.method, dup.url, dup.statusCode, dup.httpVersion, '{0}.{1}'.format(dup.httpVersionMajor, dup.httpVersionMinor), JSON.stringify(dup.headers), JSON.stringify(dup.trailers), dup.complete, dup.readable, dup.writable, dup.connection, dup.socket);
                        dup.end(output.streamline());
                    }
                    else {
                        dup.statusCode = 400;
                        dup.end('Bad Request');
                    }
                    break;
                default:
                    dup.statusCode = 404;
                    dup.end("File doesn't exist");
                    break;
            }
        });
        server.listen();
    });
    afterEach(() => {
        server.close();
    });
    test('should be able to handle requests', async () => {
        expect.assertions(3);
        await new Promise((resolve) => {
            server.on('error', (e) => {
                console.log('error', e);
            });
            server.on('listening', async function () {
                const { port } = server.address();
                const u = `http://localhost:${port}/`;
                const response = await (0, node_fetch_1.default)(u);
                const body = await response.text();
                expect(String(body)).toBe(String(selfSrc));
                const response1 = await (0, node_fetch_1.default)(u, {
                    method: 'POST',
                    body: 'beep boop\n',
                    headers: { 'Content-Type': 'text/plain' },
                });
                const body1 = await response1.text();
                expect(body1).toBe('10');
                const response2 = await (0, node_fetch_1.default)(u + 'info');
                const body2 = await response2.text();
                expect(String(body2.streamline())).toMatchInlineSnapshot(`
          "Method: GET
          Path: /info
          Status: 200
          Http Version 1: 1.1
          Http Version 2: 1.1
          Headers: 
          {\\"accept\\":\\"*/*\\"
          \\"user-agent\\":\\"node-fetch/1.0 (+https://github.com/bitinn/node-fetch)\\"
          \\"accept-encoding\\":\\"gzip
          deflate\\"
          \\"connection\\":\\"close\\"
          \\"host\\":\\"localhost:${port}\\"}
          Trailers: {}
          Complete: false
          Readable: true
          Writeable: true
          Connection: [object Object]
          Socket: [object Object]
          "
        `);
                resolve('passed');
            });
        });
    });
});
