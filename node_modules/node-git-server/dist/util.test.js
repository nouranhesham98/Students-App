"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("./util");
describe('util', () => {
    describe('basicAuth', () => {
        test('should send back basic auth headers', async () => {
            await new Promise((resolve, reject) => {
                const headers = {};
                const req = {
                    headers: {},
                };
                const res = {
                    writeHead: function (_code) {
                        code = _code;
                    },
                    setHeader: function (key, value) {
                        headers[key] = value;
                    },
                    end: function (_status) {
                        status = _status;
                        expect(code).toBe(401);
                        expect(headers).toEqual({
                            'Content-Type': 'text/plain',
                            'WWW-Authenticate': 'Basic realm="authorization needed"',
                        });
                        expect(status).toBe('401 Unauthorized');
                        resolve('passed');
                    },
                };
                let code = 0;
                let status = 0;
                (0, util_1.basicAuth)(req, res, () => {
                    reject('should not have entered this callback');
                });
            });
        });
        test('should accept headers and call callback', async () => {
            await new Promise((resolve) => {
                const req = {
                    headers: {
                        authorization: 'Basic T3BlbjpTZXNhbWU=',
                    },
                };
                const res = {};
                (0, util_1.basicAuth)(req, res, (username, password) => {
                    expect(username).toBe('Open');
                    expect(password).toBe('Sesame');
                    resolve('passed');
                });
            });
        });
    });
    describe('noCache', () => {
        test('should honor noCache', () => {
            const headers = {
                'persisted-header': 'I have been here foreveeeerrr',
            };
            const res = {
                setHeader: function (key, value) {
                    headers[key] = value;
                },
            };
            (0, util_1.noCache)(res);
            expect(headers).toEqual({
                'persisted-header': 'I have been here foreveeeerrr',
                expires: 'Fri, 01 Jan 1980 00:00:00 GMT',
                pragma: 'no-cache',
                'cache-control': 'no-cache, max-age=0, must-revalidate',
            });
        });
    });
    describe('parseGitName', () => {
        test('should remove .git from repo name', () => {
            expect((0, util_1.parseGitName)('test.git')).toBe('test');
        });
        test('should remove .git from the end of repo name but not in the middle', () => {
            expect((0, util_1.parseGitName)('test.git.git')).toBe('test.git');
        });
        test("if .git does not exist in the string, don't remove it", () => {
            expect((0, util_1.parseGitName)('test')).toBe('test');
        });
    });
});
