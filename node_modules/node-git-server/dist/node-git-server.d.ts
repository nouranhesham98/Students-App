/// <reference types="node" />

import EventEmitter from 'events';
import http from 'http';
import https from 'https';
import { ServerOptions } from 'http';
import { Socket } from 'net';

/**
 * sets and parses basic auth headers if they exist
 * @param  req  - http request object
 * @param  res  - http response
 * @param  callback - function(username, password)
 */
export declare function basicAuth(req: http.IncomingMessage, res: http.ServerResponse, callback: (username?: string, password?: string) => void): void;

/**
 * responds with the correct service depending on the action
 * @param  opts - options to pass Service
 * @param  req  - http request object
 * @param  res  - http response
 */
export declare function createAction(opts: ServiceOptions, req: http.IncomingMessage, res: http.ServerResponse): Service;

/**
 * an http duplex object (see below) with these extra properties
 */
export declare interface FetchData extends HttpDuplex {
    repo: string;
    commit: string;
}

export declare class Git extends EventEmitter implements GitEvents {
    dirMap: (dir?: string) => string;
    authenticate: ((options: GitAuthenticateOptions, callback: (error?: Error) => void | undefined) => void | Promise<Error | undefined | void> | undefined) | undefined;
    autoCreate: boolean;
    checkout: boolean | undefined;
    server: https.Server | http.Server | undefined;
    /**
     *
     * Handles invoking the git-*-pack binaries
     * @param  repoDir   - Create a new repository collection from the directory `repoDir`. `repoDir` should be entirely empty except for git repo directories. If `repoDir` is a function, `repoDir(repo)` will be used to dynamically resolve project directories. The return value of `repoDir(repo)` should be a string path specifying where to put the string `repo`. Make sure to return the same value for `repo` every time since `repoDir(repo)` will be called multiple times.
     * @param  options - options that can be applied on the new instance being created
     * @param  options.autoCreate - By default, repository targets will be created if they don't exist. You can
     disable that behavior with `options.autoCreate = true`
     * @param  options.authenticate - a function that has the following arguments ({ type, repo, username, password, headers }, next) and will be called when a request comes through if set
     *
     authenticate: ({ type, repo, username, password, headers }, next) => {
     console.log(type, repo, username, password);
     next();
     }
     // alternatively you can also pass authenticate a promise
     authenticate: ({ type, repo, username, password, headers }, next) => {
     console.log(type, repo, username, password);
     return new Promise((resolve, reject) => {
     if(username === 'foo') {
     return resolve();
     }
     return reject("sorry you don't have access to this content");
     });
     }
     * @param  options.checkout - If `opts.checkout` is true, create and expected checked-out repos instead of bare repos
     */
    constructor(repoDir: string | ((dir?: string) => string), options?: GitOptions);
    /**
     * Get a list of all the repositories
     * @param  {Function} callback function to be called when repositories have been found `function(error, repos)`
     */
    list(callback: (error: Error | undefined, repos?: string[]) => void): void;
    list(): Promise<string[]>;
    /**
     * Find out whether `repoName` exists in the callback `cb(exists)`.
     * @param  repo - name of the repo
     * @param  callback - function to be called when finished
     */
    exists(repo: string): boolean;
    /**
     * Create a subdirectory `dir` in the repo dir with a callback.
     * @param  dir - directory name
     * @param  callback  - callback to be called when finished
     */
    mkdir(dir: string): void;
    /**
     * Create a new bare repository `repoName` in the instance repository directory.
     * @param  repo - the name of the repo
     * @param  callback - Optionally get a callback `cb(err)` to be notified when the repository was created.
     */
    create(repo: string, callback: (error?: Error) => void): void;
    /**
     * returns the typeof service being process. This will respond with either fetch or push.
     * @param  service - the service type
     */
    getType(service: string): string;
    /**
     * Handle incoming HTTP requests with a connect-style middleware
     * @param  http request object
     * @param  http response object
     */
    handle(req: http.IncomingMessage, res: http.ServerResponse): void;
    /**
     * starts a git server on the given port
     * @param  port  - the port to start the server on
     * @param  options  - the options to add extended functionality to the server
     * @param  options.type - this is either https or http (the default is http)
     * @param  options.key - the key file for the https server
     * @param  options.cert - the cert file for the https server
     * @param  callback - the function to call when server is started or error has occurred
     */
    listen(port: number, options?: GitServerOptions, callback?: () => void): Git;
    /**
     * closes the server instance
     * @param will resolve or reject when the server closes or fails to close.
     */
    close(): Promise<string>;
}

export declare interface GitAuthenticateOptions {
    type: string;
    repo: string;
    user: (() => Promise<[string | undefined, string | undefined]>) & ((callback: (username?: string | undefined, password?: string | undefined) => void) => void);
    headers: http.IncomingHttpHeaders;
}

export declare interface GitEvents {
    /**
     * @example
     * repos.on('push', function (push) { ... }
     *
     * Emitted when somebody does a `git push` to the repo.
     *
     * Exactly one listener must call `push.accept()` or `push.reject()`. If there are
     * no listeners, `push.accept()` is called automatically.
     **/
    on(event: 'push', listener: (push: PushData) => void): this;
    /**
     * @example
     * repos.on('tag', function (tag) { ... }
     *
     * Emitted when somebody does a `git push --tags` to the repo.
     * Exactly one listener must call `tag.accept()` or `tag.reject()`. If there are
     * No listeners, `tag.accept()` is called automatically.
     **/
    on(event: 'tag', listener: (tag: TagData) => void): this;
    /**
     * @example
     * repos.on('fetch', function (fetch) { ... }
     *
     * Emitted when somebody does a `git fetch` to the repo (which happens whenever you
     * do a `git pull` or a `git clone`).
     *
     * Exactly one listener must call `fetch.accept()` or `fetch.reject()`. If there are
     * no listeners, `fetch.accept()` is called automatically.
     **/
    on(event: 'fetch', listener: (fetch: FetchData) => void): this;
    /**
     * @example
     * repos.on('info', function (info) { ... }
     *
     * Emitted when the repo is queried for info before doing other commands.
     *
     * Exactly one listener must call `info.accept()` or `info.reject()`. If there are
     * no listeners, `info.accept()` is called automatically.
     **/
    on(event: 'info', listener: (info: InfoData) => void): this;
    /**
     * @example
     * repos.on('head', function (head) { ... }
     *
     * Emitted when the repo is queried for HEAD before doing other commands.
     *
     * Exactly one listener must call `head.accept()` or `head.reject()`. If there are
     * no listeners, `head.accept()` is called automatically.
     *
     **/
    on(event: 'head', listener: (head: HeadData) => void): this;
}

export declare interface GitOptions {
    autoCreate?: boolean;
    authenticate?: (options: GitAuthenticateOptions, callback: (error?: Error) => void | undefined) => void | Promise<Error | undefined | void> | undefined;
    checkout?: boolean;
}

declare interface GitServerOptions extends ServerOptions {
    type: 'http' | 'https';
}

/**
 * an http duplex object (see below) with these extra properties
 */
export declare interface HeadData extends HttpDuplex {
    repo: string;
}

export declare class HttpDuplex extends EventEmitter {
    setHeader(arg0: string, arg1: string): void;
    end(reason?: any): void;
    destroy(): void;
    accept(): void;
    reject(code: number, msg: string): void;
    /**
     * A IncomingMessage created by http.Server or http.ClientRequest usually passed as the
     * first parameter to the 'request' and 'response' events. Implements Readable Stream interface
     * but may not be a decendant thereof.
     * @see {@link https://nodejs.org/api/http.html#http_event_request|request}
     * @see {@link https://nodejs.org/api/http.html#http_class_http_incomingmessage|http.IncomingMessage}
     *
     */
    req: http.IncomingMessage;
    /**
     * Created http.server. Passed as the second parameter to the 'request' event.
     * The response implements Writable Stream interface but isn't a descendent thereof.
     * @see {@link https://nodejs.org/api/http.html#http_event_request|request}
     * @see {@link https://nodejs.org/api/http.html#http_class_http_serverresponse|http.ServerResponse}
     */
    res: http.ServerResponse;
    cwd: string | undefined;
    repo: string | undefined;
    exists: boolean | undefined;
    /**
     * Constructs a proxy object over input and output resulting in a unified stream.
     * Generally meant to combine request and response streams in the http.request event
     * @see {@link https://nodejs.org/api/http.html#http_event_request|request}
     * @see {@link https://nodejs.org/api/http.html#http_class_http_incomingmessage|http.IncomingMessage}
     * @see {@link https://nodejs.org/api/http.html#http_class_http_serverresponse|http.ServerResponse}
     * @example <caption> A simple example is shown below </caption>
     ```
     http.createServer(function (req, res) {
     var dup = new HttpDuplex(req, res);
     res.end("Request: " + req.method + " " + req.url);
     }).listen(80);
     ```
     */
    constructor(input: http.IncomingMessage, output: http.ServerResponse);
    get complete(): boolean;
    /**
     * Reference to the underlying socket for the request connection.
     * @readonly
     * @see {@link https://nodejs.org/api/http.html#http_request_socket|request.Socket}
     */
    get connection(): Socket;
    /**
     * Request/response headers. Key-value pairs of header names and values. Header names are always lower-case.
     * @readonly
     * @see {@link https://nodejs.org/api/http.html#http_message_headers|message.headers}
     */
    get headers(): http.IncomingHttpHeaders;
    /**
     * Requested HTTP Version sent by the client. Usually either '1.0' or '1.1'
     * @see {@link https://nodejs.org/api/http.html#http_message_httpversion|message.httpVersion}
     * @readonly
     */
    get httpVersion(): string;
    /**
     * First integer in the httpVersion string
     * @see httpVersion
     * @readonly
     */
    get httpVersionMajor(): number;
    /**
     * Second integer ni the httpVersion string
     * @see httpVersion
     * @readonly
     */
    get httpVersionMinor(): number;
    /**
     * Request method of the incoming request.
     * @see {@link https://nodejs.org/api/http.html#http_event_request|request}
     * @see {@link https://nodejs.org/api/http.html#http_class_http_serverresponse|http.ServerResponse}
     * @example 'GET', 'DELETE'
     * @readonly
     */
    get method(): string | undefined;
    /**
     * Is this stream readable.
     * @readonly
     */
    get readable(): boolean;
    /**
     * net.Socket object associated with the connection.
     * @see {@link https://nodejs.org/api/net.html#net_class_net_socket|net.Socket}
     * @readonly
     */
    get socket(): Socket;
    /**
     * The HTTP status code. Generally assigned before sending headers for a response to a client.
     * @see {@link https://nodejs.org/api/http.html#http_response_statuscode|response.statusCode}
     * @example request.statusCode = 404;
     */
    get statusCode(): number;
    set statusCode(val: number);
    /**
     * Controls the status message sent to the client as long as an explicit call to response.writeHead() isn't made
     * If ignored or the value is undefined, the default message corresponding to the status code will be used.
     * @see {@link https://nodejs.org/api/http.html#http_response_statusmessage|response.statusMessage}
     * @example request.statusMessage = 'Document Not found';
     */
    get statusMessage(): string;
    set statusMessage(val: string);
    /**
     * Request/response trailer headers. Just like {@link headers} except these are only written
     * after the initial response to the client.
     * This object is only populated at the 'end' event and only work if a 'transfer-encoding: chunked'
     * header is sent in the initial response.
     * @readonly
     * @see headers
     * @see addTrailers
     * @see {@link https://nodejs.org/api/http.html#http_message_trailers|message.trailers}
     * @see {@link https://nodejs.org/api/http.html#http_response_addtrailers_headers|response.addTrailers}
     */
    get trailers(): NodeJS.Dict<string>;
    /**
     * Request URL string.
     * @example <caption>A request made as:</caption>
     * GET /info?check=none HTTP/1.1
     * @example <caption>Will return the string</caption>
     * '/info?check=none'
     * @readonly
     */
    get url(): string | undefined;
    get writable(): boolean;
    /**
     * Sends a response header to the client request. Must only be called one time and before calling response.end().
     * @param statusCode 3-digit HTTP status code, like 404
     * @param statusMessage - An optional human readable status message to send with the status code
     * @param headers - An object containing the response headers to send
     * @see {@link https://nodejs.org/api/http.html#http_response_writehead_statuscode_statusmessage_headers|response.writeHead}
     * @example var content = 'Under Construction...';
     * response.writeHead(200, {
     *     'Content-Length': Buffer.byteLength(content),
     *     'Content-Type': 'text/plain'
     * });
     * response.end(content);
     */
    writeHead(statusCode: number, statusMessage: string, headers: string[]): this;
    /**
     * Buffers written data in memory. This data will be flushed when either the uncork or end methods are called.
     * @see uncork
     * @see {@link https://nodejs.org/api/stream.html#stream_writable_cork|stream.Writeable.cork}
     * @example
     * request.cork();
     * request.write('buffer data ');
     * request.write('before sending ');
     * request.uncork();
     */
    cork(): this;
    /**
     * Flushes all data buffered since cork() was called.
     * @see cork
     * @see {@link https://nodejs.org/api/stream.html#stream_writable_uncork|stream.Writeable.uncork}
     */
    uncork(): this;
}

/**
 * an http duplex object (see below) with these extra properties
 */
export declare interface InfoData extends HttpDuplex {
    repo: string;
}

/**
 * sends http response using the appropriate output from service call
 * @param  git     - an instance of git object
 * @param  repo    - the repository
 * @param  service - the method that is responding infoResponse (push, pull, clone)
 * @param  req  - http request object
 * @param  res  - http response
 */
export declare function infoResponse(git: Git, repo: string, service: ServiceString, req: http.IncomingMessage, res: http.ServerResponse): void;

/**
 * adds headers to the response object to add cache control
 * @param  res  - http response
 */
export declare function noCache(res: http.ServerResponse): void;

export declare function packSideband(s: string): string;

/**
 * parses a git string and returns the repo name
 * @param  repo - the raw repo name containing .git
 */
export declare function parseGitName(repo: string): string;

/**
 * Is a http duplex object (see below) with these extra properties
 */
export declare interface PushData extends HttpDuplex {
    repo: string;
    commit: string;
    branch: string;
}

export declare class Service extends HttpDuplex {
    status: string;
    repo: string;
    service: string;
    cwd: string;
    logs: string[];
    last: string | undefined;
    commit: string | undefined;
    evName: string | undefined;
    username: string | undefined;
    /**
     * Handles invoking the git-*-pack binaries
     * @param  opts - options to bootstrap the service object
     * @param  req  - http request object
     * @param  res  - http response
     */
    constructor(opts: ServiceOptions, req: http.IncomingMessage, res: http.ServerResponse);
    log(): void;
    /**
     * reject request in flight
     * @param  code - http response code
     * @param  msg  - message that should be displayed on the client
     */
    reject(code: number, msg: string): void;
    /**
     * accepts request to access resource
     */
    accept(): void;
}

export declare interface ServiceOptions {
    repo: string;
    cwd: string;
    service: ServiceString;
}

/**
 * execute given git operation and respond
 * @param  dup  - duplex object to catch errors
 * @param  service - the method that is responding infoResponse (push, pull, clone)
 * @param  repoLocation - the repo path on disk
 * @param  res  - http response
 */
export declare function serviceRespond(dup: HttpDuplex | Git, service: ServiceString, repoLocation: string, res: http.ServerResponse): void;

export declare type ServiceString = 'upload-pack' | 'receive-pack';

/**
 * An http duplex object (see below) with these extra properties:
 */
export declare interface TagData extends HttpDuplex {
    repo: string;
    commit: string;
    version: string;
}

export { }
